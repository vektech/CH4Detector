C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE ..\..\Code\Source\main.c LARGE OPTIMIZE(8,SPEED) BROWSE
                    - INCDIR(..\..\Code\Include) DEBUG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2           *******************************************************************************
   3           * @copyright 2017-2020, Electronic Technology Co. Ltd
   4           * @file      main.c
   5           * @version   V1.0.0
   6           * @brief     
   7           * @warning   
   8           *******************************************************************************
   9           * @remarks
  10           * 1. Version                Date                 Author
  11           *    v1.0.0                 2020年1月1日          Unknown
  12           *    Modification: 创建文档
  13           *******************************************************************************
  14           */
  15          /* NEED FIX */
  16          /*******************************************************************************
  17           *                 Include File Section ('#include')
  18           ******************************************************************************/
  19          #include "N79E81x.h"
  20          #include "GlobalAppDefine.h"
  21          #include "GlobalFormat8051Core.h"
  22          
  23          #include "uart.h"
  24          #include "delay.h"
  25          #include "sensor.h"
  26          #include "device.h"
  27          #include "signal.h"
  28          
  29          /*******************************************************************************
  30           *                 Macro Define Section ('#define')
  31           ******************************************************************************/
  32          /*
  33          /*
  34          P2.0 蜂鸣器2
  35          P2.1 蜂鸣器1
  36          P2.3 继电器
  37          P2.4 报警灯
  38          P2.5 故障灯
  39          P2.6 传感器寿命灯
  40          
  41          P1.3  SDA
  42          P1.2  SCL
  43          P1.1  RXD
  44          P1.0  TXD
  45          P1.4  T_INT
  46          
  47          P0.0  电磁阀
  48          P0.1  传感器AD采样
  49          P0.2  电磁阀检测
  50          P0.3  电源灯
  51          P0.5  电源电压检测
  52          P0.6  调试、标定
  53          P0.7  测试按键
  54          */
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 2   

  55          /*******************************************************************************
  56           *                 Struct Define Section ('typedef')
  57           ******************************************************************************/
  58          
  59          /*******************************************************************************
  60           *                 File Static Prototype Declare Section ('static function')
  61           ******************************************************************************/
  62          
  63          /*******************************************************************************
  64           *                 Global Variable Declare Section ('variable')
  65           ******************************************************************************/
  66          
  67          /*******************************************************************************
  68           *                 File Static Variable Define Section ('static variable')
  69           ******************************************************************************/
  70          
  71          /*******************************************************************************
  72           *                 Normal Function Define Section ('function')
  73           ******************************************************************************/
  74          void main(void)
  75          {
  76   1          /* 传感器寿命到期检测标志 */
  77   1          uint8_t life_check[4] = {0x00, 0x00, 0x00, 0x00};
  78   1          uint8_t life_check_flag = 0;
  79   1      
  80   1          /* 设备初始化 */
  81   1          // device_init();
  82   1          
  83   1          /* 设备标定 */
  84   1          // sersor_demarcation();
  85   1      
  86   1          /* XXX 上电状态位为0 进行一次上电记录 */
  87   1          // if (device_first_power_on == false)
  88   1          // {
  89   1          //     device_first_power_on = true;
  90   1          //     /* 进行上电记录 */
  91   1          //     WriteRecordData(UPPOWER_RECORD);
  92   1          // }
  93   1      
  94   1          // /* 关闭全局中断 */
  95   1          // EA = 0;
  96   1          // /* 关键SFR读写保护 */
  97   1          // TA = 0xAA;
  98   1          // TA = 0x55;
  99   1          // /* PMCR电源检测控制寄存器设置 PMCR = 1100 0000B 
 100   1          //     - BODEN[7]       = 1B 使能欠压检测
 101   1          //     - BOV[6]         = 1B 结合CBOV 设置欠压检测为3.8V
 102   1          //     - Reserved3[5]   = 0B
 103   1          //     - BORST[4]       = 0B 当VDD下降或上升至VBOD 禁止欠压检测复位 当VDD下降至VBOD以下 芯片将置位BOF 
 104   1          //     - BOF[3]         = 0B 欠压检测标志位 当VDD下降或上升至VBOD置位
 105   1          //     - Reserved2[2]   = 0B 必须为0
 106   1          //     - Reserved1[1:0] = 00B 
 107   1          //     */
 108   1          // PMCR = 0xc0;
 109   1      
 110   1          // /* 开启全局中断 */
 111   1          // EA = 1;
 112   1          // /* EBO 为BOD电源电压检测的中断使能位 开中断 sbit EBO = IE ^ 5 */
 113   1          // EBO = 1;
 114   1      
 115   1          // device_first_power_down = down_flag = 0;
 116   1          // timer2_life_second_count = bReadtime = sensor_preheat = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 3   

 117   1      
 118   1          // /* WARMUP 设置系统状态 status[1] &= 0x1f */
 119   1          // STATUS1_WARMUP;
 120   1      
 121   1          // /* 读取按键 P0.7 的值 检查自检功能是否触发 */
 122   1          // Test_key = P07 & 0x01;
 123   1          // /* 测试键按下 */
 124   1          // if (Test_key == 0x00)
 125   1          // {   
 126   1          //     /* 延时去抖 */
 127   1          //     Delay1ms(50);
 128   1          //     /* 测试按键按下时长计算 */
 129   1          //     while ((P07 & 0x01) == 0x00)
 130   1          //     {
 131   1          //         /* XXX */
 132   1          //         if (timer2_life_second_count > 1)
 133   1          //         {
 134   1          //             /* NOMAL 设置系统状态 status[1] = (status[1] & 0x1f) | 0X20 */
 135   1          //             STATUS1_NOMAL;
 136   1          //             sensor_preheat = 1;
 137   1      
 138   1          //             /* 控制四颗灯闪烁和蜂鸣器鸣响 */
 139   1          //             Light_Flash();
 140   1          //             break;
 141   1          //         }
 142   1          //     }
 143   1          // }
 144   1          // /* XXX */
 145   1          // timer2_life_second_count = 0;
 146   1      
 147   1          // /* ---- 时钟检测 ---- */
 148   1          // /* 从Flash存储地址(RECORD_FIRST_ADDRESS[LIFE_RECORD] + 30) 中读取寿命到期信息 */
 149   1          // ReadData(LifeCheck, RECORD_FIRST_ADDRESS[LIFE_RECORD] + 30, 4);
 150   1          // /* Life_Check_flag表示 线上设置了时钟 */
 151   1          // if (LifeCheck[0] == 0xa5 && (LifeCheck[1] == 0x36))
 152   1          // {
 153   1          //     if (LifeCheck[2] == 0x5a && (LifeCheck[3] == 0xe7))
 154   1          //         Life_Check_flag = 1;
 155   1          // }
 156   1      
 157   1          // while (1)
 158   1          // {
 159   1          //     /* XXX 寿命到期 */
 160   1          //     if (Life_Check_flag == 0)
 161   1          //         LED_LIFE_ON;
 162   1      
 163   1          //     /* XXX 预热完成 */
 164   1          //     if (sensor_preheat)
 165   1          //     {
 166   1          //         /* 电源灯开 */
 167   1          //         LED_POWER_ON;
 168   1      
 169   1          //         /* XXX 没有从FLASH中读取标定值 */
 170   1          //         if (!bReaddemarcation_result)
 171   1          //         {
 172   1          //             bReaddemarcation_result = 1;
 173   1          //             i = 0;
 174   1          //             /* 尝试从FLASH中读取标定数据 10次 */
 175   1          //             while (i < 10)
 176   1          //             {
 177   1          //                 /* XXX 开启I2C 并进行时间写入 */
 178   1          //                 startClock();
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 4   

 179   1          //                 /* 从FLASH中读取标定数据 */
 180   1          //                 ReadData(demarcation_result, RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD] + Life_st
             -art_OFFSET_DEMA_CH4_0, 4);
 181   1      
 182   1          //                 /* 设置 ch4_0 */
 183   1          //                 ch4_0 = demarcation_result[1];
 184   1          //                 ch4_0 = ch4_0 << 8;
 185   1          //                 ch4_0 |= demarcation_result[0];
 186   1          //                 /* 设置 ch4_3500 */
 187   1          //                 ch4_3500 = demarcation_result[3];
 188   1          //                 ch4_3500 = ch4_3500 << 8;
 189   1          //                 ch4_3500 |= demarcation_result[2];
 190   1      
 191   1          //                 /* 如果未标定或者读取的标定数据有误 则设置默认的报警阈值 ch4_0 = 150 ch4_3500 = 750
             - */
 192   1          //                 if (ch4_3500 >= 1024 || (ch4_3500 <= ch4_0) || (ch4_0 <= 0))
 193   1          //                 {
 194   1          //                     ch4_0 = 150;
 195   1          //                     ch4_3500 = 750;
 196   1          //                 }
 197   1          //                 /* 标定数据无误 跳出 */
 198   1          //                 else
 199   1          //                 {
 200   1          //                     break;
 201   1          //                 }
 202   1          //                 i++;
 203   1          //             }
 204   1          //         }
 205   1          //     }
 206   1      
 207   1          //     /* XXX */
 208   1          //     if (!(timer2_life_second_count % 2))
 209   1          //     {
 210   1          //         /* XXX 没有从I2C中读取时间 */
 211   1          //         if (!bReadtime)
 212   1          //         {
 213   1          //             bReadtime = 1;
 214   1          //             /* Brown-Out Detector 电源电压检测 */
 215   1          //             check_BOD();
 216   1          //             /* 读取当前时间 存入Time_Code */
 217   1          //             Master_Read_Data();
 218   1          //             /* XXX */
 219   1          //             if (i2c_time_code[6] < 15 || (i2c_time_code[5] > 12) || (i2c_time_code[3] > 31) || (i2c
             -_time_code[2] > 23) || (i2c_time_code[1] > 59) || (i2c_time_code[0] > 59))
 220   1          //             {
 221   1          //                 /* XXX 将 timeCOPY 转换为 i2c_time_code */
 222   1          //                 timecopyTotimecode();
 223   1          //             }
 224   1          //             else
 225   1          //             {
 226   1          //                 /* EBO 为BOD电源电压检测的中断使能位 关中断 sbit EBO = IE ^ 5 */
 227   1          //                 EBO = 0;
 228   1          //                 /* XXX 复制从时钟芯片获取的时间戳 将 i2c_time_code 转换为 timeCOPY */
 229   1          //                 timecodeTotimecopy();
 230   1          //                 /* EBO 为BOD电源电压检测的中断使能位 开中断 sbit EBO = IE ^ 5 */
 231   1          //                 EBO = 1;
 232   1          //             }
 233   1          //         }
 234   1          //     }
 235   1          //     else
 236   1          //     {
 237   1          //         bReadtime = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 5   

 238   1          //     }
 239   1      
 240   1          //     /* Brown-Out Detector 电源电压检测 */
 241   1          //     check_BOD();
 242   1      
 243   1          //     /* ADC初始化 */
 244   1          //     adc_init();
 245   1      
 246   1          //     /* 得到ADC采样并滤波之后的值 */
 247   1          //     CH4_Adc_Valu = adc_sensor();
 248   1      
 249   1          //     /* ---- UART 通讯程序段 ----*/
 250   1          //     /* UART接收完成 */
 251   1          //     if (rxfinish)
 252   1          //     {   
 253   1          //         /* 取第一个字节的最高一位 如果为0B 表示是工装板发来的命令 */
 254   1          //         if (!(rxbuf[0] & 0x80))
 255   1          //         {
 256   1          //             if (rxidx >= 9)
 257   1          //             {
 258   1          //                 if (Get_crc(rxbuf, rxidx) == rxbuf[rxidx - 2])
 259   1          //                 {
 260   1          //                     for (i = 0; i < 5; i++)
 261   1          //                     {
 262   1          //                         if (SERIAL_ADD[i + 3] != rxbuf[i + 1])
 263   1          //                             break;
 264   1          //                     }
 265   1          //                     /* 表示地址对上了 */
 266   1          //                     if (i == 5)
 267   1          //                     {
 268   1          //                         for (i = 6; i < rxidx; i++)
 269   1          //                         {
 270   1          //                             /* 把地址信息从接收帧中去掉 */
 271   1          //                             rxbuf[i - 5] = rxbuf[i];
 272   1          //                         }
 273   1          //                         /* 把地址的字节数减去 */
 274   1          //                         rxidx -= 5;
 275   1          //                         /* 把命令恢复 */ 
 276   1          //                         rxbuf[0] |= 0x80;
 277   1          //                         /* 重新计算crc */
 278   1          //                         rxbuf[rxidx - 2] = Get_crc(rxbuf, rxidx);
 279   1          //                     }
 280   1          //                     else
 281   1          //                     {
 282   1          //                         rxbuf[0] = 0x00;
 283   1          //                     }
 284   1          //                 }
 285   1          //                 else
 286   1          //                 {
 287   1          //                     rxbuf[0] = 0x00;
 288   1          //                 }
 289   1          //             }
 290   1          //             else
 291   1          //             {
 292   1          //                 rxbuf[0] = 0x00;
 293   1          //             }
 294   1          //         }
 295   1      
 296   1          //         switch (rxbuf[0])
 297   1          //         {
 298   1          //         /* 0xab开头为写命令 */
 299   1          //         case 0xab:
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 6   

 300   1          //         {
 301   1          //             switch (rxbuf[1])
 302   1          //             {
 303   1          //             /* 擦除EEP */
 304   1          //             case 0x00:
 305   1          //             {
 306   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_EASE_REC[0]) == rxbuf[COMMAND_LEN_EASE_REC[0] - 2])
 307   1          //                 {
 308   1          //                     for (i = 1; i <= 8; i++)
 309   1          //                     {
 310   1          //                         ease_page(RECORD_FIRST_ADDRESS[i]);
 311   1          //                         /* Brown-Out Detector 电源电压检测 */
 312   1          //                         check_BOD();
 313   1          //                     }
 314   1      
 315   1          //                     rxbuf[3] = status[1] & 0xe0;
 316   1          //                 }
 317   1          //                 else
 318   1          //                 {
 319   1          //                     rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 320   1          //                 }
 321   1          //                 rxbuf[2] = status[0];
 322   1          //                 rxbuf[COMMAND_LEN_EASE_REC[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_EASE_REC[1]);
 323   1          //                 rxbuf[COMMAND_LEN_EASE_REC[1] - 1] = 0x55;
 324   1          //                 for (i = 0; i < COMMAND_LEN_EASE_REC[1]; i++)
 325   1          //                 {
 326   1          //                     uart_send(rxbuf[i]);
 327   1          //                     /* 串口输出 延时函数 关键参数 */
 328   1          //                     Delay1ms(5);
 329   1          //                 }
 330   1      
 331   1          //                 break;
 332   1          //             }
 333   1          //             /* 写时钟指令 */
 334   1          //             case 0x01:
 335   1          //             {
 336   1          //                 /* 写时钟指令 */
 337   1          //                 if ((rxidx >= COMMAND_LEN_WRITE_CLOCK[0]))
 338   1          //                 {
 339   1          //                     if (Get_crc(rxbuf, COMMAND_LEN_WRITE_CLOCK[0]) == rxbuf[COMMAND_LEN_WRITE_CLOCK
             -[0] - 2])
 340   1          //                     {
 341   1          //                         if (rxbuf[2] < 15)
 342   1          //                         {
 343   1          //                             rxbuf[3] = (status[1] & 0xe0) | ILLEGAL_PARA_EROR;
 344   1          //                             goto WR_CLOCK_EROR;
 345   1          //                         }
 346   1          //                         if (rxbuf[3] > 12 || (!rxbuf[3]))
 347   1          //                         {
 348   1          //                             rxbuf[3] = (status[1] & 0xe0) | ILLEGAL_PARA_EROR;
 349   1          //                             goto WR_CLOCK_EROR;
 350   1          //                         }
 351   1          //                         if (rxbuf[4] > 31 || (!rxbuf[4]))
 352   1          //                         {
 353   1          //                             rxbuf[3] = (status[1] & 0xe0) | ILLEGAL_PARA_EROR;
 354   1          //                             goto WR_CLOCK_EROR;
 355   1          //                         }
 356   1      
 357   1          //                         if ((rxbuf[5] > 23) || (rxbuf[6] > 59) || (rxbuf[7] > 59))
 358   1          //                         {
 359   1          //                             rxbuf[3] = (status[1] & 0xe0) | ILLEGAL_PARA_EROR;
 360   1          //                             goto WR_CLOCK_EROR;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 7   

 361   1          //                         }
 362   1      
 363   1          //                         for (i = 2; i < 8; i++)
 364   1          //                         {
 365   1          //                             /* 十六进制转为BCD码 */
 366   1          //                             i2c_time_code[8 - i] = hex2bcd(rxbuf[i]);
 367   1          //                         }
 368   1          //                         i2c_time_code[0] = i2c_time_code[1];
 369   1          //                         i2c_time_code[1] = i2c_time_code[2];
 370   1          //                         i2c_time_code[2] = i2c_time_code[3];
 371   1          //                         i2c_time_code[3] = i2c_time_code[4];
 372   1          //                         i2c_time_code[4] = 0;
 373   1      
 374   1          //                         /* 写入数据 */
 375   1          //                         Master_Write_Data();
 376   1      
 377   1          //                         Delay1ms(100);
 378   1          //                         Master_Read_Data();
 379   1          //                         /* 月：表示写入时间不成功 */
 380   1          //                         if (i2c_time_code[5] != rxbuf[3] && (i2c_time_code[5] != (rxbuf[3] + 1)))
 381   1          //                         {
 382   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 383   1          //                             ;
 384   1          //                         }
 385   1          //                         else
 386   1          //                         {
 387   1          //                             rxbuf[3] = (status[1] & 0xe0);
 388   1          //                         }
 389   1          //                         /* 年：表示写入时间不成功 */
 390   1          //                         if (i2c_time_code[6] != rxbuf[2] && (i2c_time_code[6] != (rxbuf[2] + 1)))
 391   1          //                         {
 392   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 393   1          //                         }
 394   1          //                         /* 日：表示写入时间不成功 */
 395   1          //                         if (i2c_time_code[3] != rxbuf[4] && (i2c_time_code[3] != (rxbuf[4] + 1)))
 396   1          //                         {
 397   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 398   1          //                         }
 399   1          //                         /* 时：表示写入时间不成功 */
 400   1          //                         if (i2c_time_code[2] != rxbuf[5] && (i2c_time_code[2] != (rxbuf[5] + 1)))
 401   1          //                         {
 402   1          //                             if (!((rxbuf[5] == 23) && (i2c_time_code[2] == 0)))
 403   1          //                                 rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 404   1          //                         }
 405   1          //                         /* 分：表示写入时间不成功 */
 406   1          //                         if (i2c_time_code[1] != rxbuf[6] && (i2c_time_code[1] != (rxbuf[6] + 1)))
 407   1          //                         {
 408   1          //                             if (!((rxbuf[6] == 59) && (i2c_time_code[1] == 0)))
 409   1          //                                 rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 410   1          //                         }
 411   1          //                     }
 412   1          //                     else
 413   1          //                     {
 414   1          //                         rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 415   1          //                         ;
 416   1          //                     }
 417   1          //                 }
 418   1          //                 else
 419   1          //                 {
 420   1          //                     rxbuf[3] = (status[1] & 0xe0) | BYTELOSS_EROR;
 421   1          //                 }
 422   1          //             WR_CLOCK_EROR:
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 8   

 423   1          //                 rxbuf[2] = status[0];
 424   1          //                 rxbuf[COMMAND_LEN_WRITE_CLOCK[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_WRITE_CLOCK[1]);
 425   1          //                 rxbuf[COMMAND_LEN_WRITE_CLOCK[1] - 1] = 0x55;
 426   1          //                 for (i = 0; i < COMMAND_LEN_WRITE_CLOCK[1]; i++)
 427   1          //                 {
 428   1          //                     uart_send(rxbuf[i]);
 429   1          //                     /* 串口输出  延时函数，关键参数 */
 430   1          //                     Delay1ms(5);
 431   1          //                 }
 432   1      
 433   1          //                 /* 表示时钟写入成功 没有发生错误 */
 434   1          //                 if ((rxbuf[3] & (~0xe0)) == 0)
 435   1          //                 {
 436   1          //                     LifeCheck[0] = 0xa5;
 437   1          //                     LifeCheck[1] = 0x36;
 438   1          //                     Life_Check_flag = 1;
 439   1          //                     WriteData(LifeCheck, 4, RECORD_FIRST_ADDRESS[LIFE_RECORD], 30);
 440   1          //                 }
 441   1          //                 break;
 442   1          //             }
 443   1          //             /* 写传感器寿命的超始时间 即出厂日期 */
 444   1          //             case 0x02:
 445   1          //             {
 446   1          //                 if ((rxidx >= COMMAND_LEN_WR_DATEOFPRODUCTION[0])) 
 447   1          //                 {
 448   1          //                     if (Get_crc(rxbuf, COMMAND_LEN_WR_DATEOFPRODUCTION[0]) == rxbuf[COMMAND_LEN_WR_
             -DATEOFPRODUCTION[0] - 2]) //
 449   1          //                     {
 450   1          //                         WriteData(&rxbuf[2], 5, RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD], 0);
 451   1          //                         ReadData(&rxbuf[7], RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD], 5);
 452   1          //                         if (rxbuf[8] != rxbuf[3])
 453   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 454   1          //                         else
 455   1          //                             rxbuf[3] = (status[1] & 0xe0);
 456   1          //                         if (rxbuf[7] != rxbuf[2])
 457   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 458   1          //                         if (rxbuf[9] != rxbuf[4])
 459   1          //                             rxbuf[3] = (status[1] & 0xe0) | Unknown_EROR;
 460   1          //                     }
 461   1          //                     else
 462   1          //                     {
 463   1          //                         rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 464   1          //                     }
 465   1          //                 }
 466   1          //                 else
 467   1          //                 {
 468   1          //                     rxbuf[3] = (status[1] & 0xe0) | BYTELOSS_EROR;
 469   1          //                 }
 470   1          //                 rxbuf[2] = status[0];
 471   1          //                 rxbuf[COMMAND_LEN_WR_DATEOFPRODUCTION[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_WR_DATEO
             -FPRODUCTION[1]);
 472   1          //                 rxbuf[COMMAND_LEN_WR_DATEOFPRODUCTION[1] - 1] = 0x55;
 473   1      
 474   1          //                 for (i = 0; i < COMMAND_LEN_WR_DATEOFPRODUCTION[1]; i++)
 475   1          //                 {
 476   1          //                     uart_send(rxbuf[i]);
 477   1          //                     /* 串口输出 延时函数 关键参数 */
 478   1          //                     Delay1ms(5);
 479   1          //                 }
 480   1          //                 /* 表示出厂日期写入成功 */
 481   1          //                 if ((rxbuf[3] & (~0xe0)) == 0)
 482   1          //                 {
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 9   

 483   1          //                     LifeCheck[2] = 0x5a;
 484   1          //                     LifeCheck[3] = 0xe7;
 485   1          //                     Life_Check_flag = 1;
 486   1          //                     WriteData(LifeCheck, 4, RECORD_FIRST_ADDRESS[LIFE_RECORD], 30);
 487   1          //                 }
 488   1          //                 break;
 489   1          //             }
 490   1          //             default:
 491   1          //             {
 492   1          //                 rxbuf[2] = status[0];
 493   1          //                 rxbuf[3] = (status[1] & 0xe0) | COMMAND_EROR;
 494   1          //                 rxbuf[4] = Get_crc(rxbuf, 6);
 495   1          //                 rxbuf[5] = 0x55;
 496   1          //                 for (i = 0; i < 6; i++)
 497   1          //                 {
 498   1          //                     uart_send(rxbuf[i]);
 499   1          //                     /* 串口输出 延时函数 关键参数 */
 500   1          //                     Delay1ms(5);
 501   1          //                 }
 502   1          //                 break;
 503   1          //             }
 504   1          //             }
 505   1          //             break;
 506   1          //         }
 507   1          //         /* 0xaa开头为 国标规定的协议 读命令 */
 508   1          //         case 0xaa:
 509   1          //         {
 510   1          //             /* 检测查询的记录类型 应小于0x09 */
 511   1          //             if (rxbuf[2] <= GBCOMMANDMAX)
 512   1          //             {
 513   1          //                 /* 所查询的索引号小于该类型的记录总数 */
 514   1          //                 if ((rxbuf[1] <= RecordLEN[rxbuf[2]]))
 515   1          //                 {
 516   1          //                     /* 若检查校验和通过 */
 517   1          //                     if ((rxidx >= (READFrameLEN - 1)) && rxbuf[4] == Get_crc(rxbuf, READFrameLEN))
 518   1          //                     {
 519   1          //                         ReadRecordData(rxbuf[2], rxbuf[1]);
 520   1          //                     }
 521   1          //                 }
 522   1          //             }
 523   1          //             break;
 524   1          //         }
 525   1          //         /* 0xac开头 为读命令 */
 526   1          //         case 0xac:
 527   1          //         {
 528   1          //             switch (rxbuf[1])
 529   1          //             {
 530   1          //             /* 读时间 带秒 */
 531   1          //             case 0x01:
 532   1          //             {
 533   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_CLOCK[0]) == rxbuf[COMMAND_LEN_RE_CLOCK[0] - 2])
 534   1          //                 {
 535   1          //                     rxbuf[3] = status[1] & 0xe0;
 536   1          //                 }
 537   1          //                 else
 538   1          //                 {
 539   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 540   1          //                 }
 541   1          //                 rxbuf[2] = status[0];
 542   1          //                 Master_Read_Data();
 543   1          //                 rxbuf[4] = i2c_time_code[6];
 544   1          //                 rxbuf[5] = i2c_time_code[5];
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 10  

 545   1          //                 rxbuf[6] = i2c_time_code[3];
 546   1          //                 rxbuf[7] = i2c_time_code[2];
 547   1          //                 rxbuf[8] = i2c_time_code[1];
 548   1          //                 rxbuf[9] = i2c_time_code[0];
 549   1          //                 rxbuf[COMMAND_LEN_RE_CLOCK[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_CLOCK[1]);
 550   1          //                 rxbuf[COMMAND_LEN_RE_CLOCK[1] - 1] = 0x55;
 551   1          //                 for (i = 0; i < COMMAND_LEN_RE_CLOCK[1]; i++)
 552   1          //                 {
 553   1          //                     uart_send(rxbuf[i]);
 554   1          //                     /* 串口输出 延时函数 关键参数 */
 555   1          //                     Delay1ms(5);
 556   1          //                 }
 557   1          //                 break;
 558   1          //             }
 559   1      
 560   1          //             /* 读模组型号等信息 */
 561   1          //             case 0x02:
 562   1          //             {
 563   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_MODEL[0]) == rxbuf[COMMAND_LEN_RE_MODEL[0] - 2])
 564   1          //                 {
 565   1          //                     rxbuf[3] = status[1] & 0xe0;
 566   1          //                 }
 567   1          //                 else
 568   1          //                 {
 569   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 570   1          //                 }
 571   1          //                 rxbuf[2] = status[0];
 572   1      
 573   1          //                 rxbuf[4] = 0x01;
 574   1          //                 rxbuf[5] = 0;
 575   1          //                 rxbuf[6] = 0;
 576   1          //                 rxbuf[7] = 0;
 577   1          //                 rxbuf[8] = 0;
 578   1          //                 rxbuf[9] = 0;
 579   1          //                 rxbuf[COMMAND_LEN_RE_MODEL[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_MODEL[1]);
 580   1          //                 rxbuf[COMMAND_LEN_RE_MODEL[1] - 1] = 0x55;
 581   1          //                 for (i = 0; i < COMMAND_LEN_RE_MODEL[1]; i++)
 582   1          //                 {
 583   1          //                     uart_send(rxbuf[i]);
 584   1          //                     /* 串口输出 延时函数 关键参数 */
 585   1          //                     Delay1ms(5);
 586   1          //                 }
 587   1          //                 break;
 588   1          //             }
 589   1          //             /* 读AD */
 590   1          //             case 0x03:
 591   1          //             {
 592   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_CURTAD[0]) == rxbuf[COMMAND_LEN_RE_CURTAD[0] - 2]
             -)
 593   1          //                 {
 594   1          //                     rxbuf[3] = status[1] & 0xe0;
 595   1          //                 }
 596   1          //                 else
 597   1          //                 {
 598   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 599   1          //                 }
 600   1          //                 rxbuf[2] = status[0];
 601   1      
 602   1          //                 rxbuf[4] = CH4_Adc_Valu >> 8;
 603   1          //                 rxbuf[5] = CH4_Adc_Valu;
 604   1          //                 rxbuf[COMMAND_LEN_RE_CURTAD[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_CURTAD[1]);
 605   1          //                 rxbuf[COMMAND_LEN_RE_CURTAD[1] - 1] = 0x55;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 11  

 606   1          //                 for (i = 0; i < COMMAND_LEN_RE_CURTAD[1]; i++)
 607   1          //                 {
 608   1          //                     uart_send(rxbuf[i]);
 609   1          //                     /* 串口输出 延时函数 关键参数 */
 610   1          //                     Delay1ms(5);
 611   1          //                 }
 612   1          //                 break;
 613   1          //             }
 614   1          //             /* 读标定相关信息 */
 615   1          //             case 0x04:
 616   1          //             {
 617   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_DEMA[0]) == rxbuf[COMMAND_LEN_RE_DEMA[0] - 2])
 618   1          //                 {
 619   1          //                     rxbuf[3] = status[1] & 0xe0;
 620   1          //                 }
 621   1          //                 else
 622   1          //                 {
 623   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 624   1          //                 }
 625   1          //                 rxbuf[2] = status[0];
 626   1          //                 ReadData(&rxbuf[4], RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD] + Life_start_OFFSE
             -T_DEMA_CH4_0, 4);
 627   1          //                 rxbuf[8] = rxbuf[4];
 628   1          //                 rxbuf[4] = rxbuf[5];
 629   1          //                 rxbuf[5] = rxbuf[8];
 630   1          //                 rxbuf[8] = rxbuf[6];
 631   1          //                 rxbuf[6] = rxbuf[7];
 632   1          //                 rxbuf[7] = rxbuf[8];
 633   1          //                 rxbuf[COMMAND_LEN_RE_DEMA[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_DEMA[1]);
 634   1          //                 rxbuf[COMMAND_LEN_RE_DEMA[1] - 1] = 0x55;
 635   1          //                 for (i = 0; i < COMMAND_LEN_RE_DEMA[1]; i++)
 636   1          //                 {
 637   1          //                     uart_send(rxbuf[i]);
 638   1          //                     /* 串口输出 延时函数 关键参数 */
 639   1          //                     Delay1ms(5);
 640   1          //                 }
 641   1          //                 break;
 642   1          //             }
 643   1          //             /* 读传感器寿命的超始时间 即出厂日期 */
 644   1          //             case 0x05:
 645   1          //             {
 646   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_DATEOFPRODUCTION[0]) == rxbuf[COMMAND_LEN_RE_DATE
             -OFPRODUCTION[0] - 2])
 647   1          //                 {
 648   1          //                     rxbuf[2] = status[0];
 649   1          //                     rxbuf[3] = status[1] & 0xe0;
 650   1          //                 }
 651   1          //                 else
 652   1          //                 {
 653   1          //                     rxbuf[2] = status[0];
 654   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 655   1          //                 }
 656   1          //                 ReadData(&rxbuf[4], RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD], 5);
 657   1          //                 rxbuf[COMMAND_LEN_RE_DATEOFPRODUCTION[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_DATEO
             -FPRODUCTION[1]);
 658   1          //                 rxbuf[COMMAND_LEN_RE_DATEOFPRODUCTION[1] - 1] = 0x55;
 659   1          //                 for (i = 0; i < COMMAND_LEN_RE_DATEOFPRODUCTION[1]; i++)
 660   1          //                 {
 661   1          //                     uart_send(rxbuf[i]);
 662   1          //                     /* 串口输出 延时函数 关键参数 */
 663   1          //                     Delay1ms(5);
 664   1          //                 }
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 12  

 665   1          //                 break;
 666   1          //             }
 667   1          //             /* 读序列号 */
 668   1          //             case 0x06:
 669   1          //             {
 670   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_RE_SERIALNUM[0]) == rxbuf[COMMAND_LEN_RE_SERIALNUM[0
             -] - 2])
 671   1          //                 {
 672   1          //                     rxbuf[2] = status[0];
 673   1          //                     rxbuf[3] = status[1] & 0xe0;
 674   1          //                 }
 675   1          //                 else
 676   1          //                 {
 677   1          //                     rxbuf[2] = status[0];
 678   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 679   1          //                 }
 680   1      
 681   1          //                 for (i = 0; i < 8; i++)
 682   1          //                 {
 683   1          //                     rxbuf[4 + i] = SERIAL_ADD[i];
 684   1          //                 }
 685   1          //                 rxbuf[COMMAND_LEN_RE_SERIALNUM[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_RE_SERIALNUM[1]
             -);
 686   1          //                 rxbuf[COMMAND_LEN_RE_SERIALNUM[1] - 1] = 0x55;
 687   1          //                 for (i = 0; i < COMMAND_LEN_RE_SERIALNUM[1]; i++)
 688   1          //                 {
 689   1          //                     uart_send(rxbuf[i]);
 690   1          //                     /* 串口输出 延时函数 关键参数 */
 691   1          //                     Delay1ms(5);
 692   1          //                 }
 693   1          //                 break;
 694   1          //             }
 695   1          //             default:
 696   1          //             {
 697   1      
 698   1          //                 rxbuf[2] = status[0];
 699   1          //                 rxbuf[3] = (status[1] & 0xe0) | COMMAND_EROR;
 700   1          //                 rxbuf[4] = Get_crc(rxbuf, 6);
 701   1          //                 rxbuf[5] = 0x55;
 702   1          //                 for (i = 0; i < 6; i++)
 703   1          //                 {
 704   1          //                     uart_send(rxbuf[i]);
 705   1          //                     /* 串口输出 延时函数 关键参数 */
 706   1          //                     Delay1ms(5);
 707   1          //                 }
 708   1          //                 break;
 709   1          //             }
 710   1          //             }
 711   1          //             break;
 712   1          //         }
 713   1          //         case 0xad:
 714   1          //         {
 715   1          //             switch (rxbuf[1])
 716   1          //             {
 717   1          //             /* 取消预热 */
 718   1          //             case 0x01:
 719   1          //             {
 720   1          //                 if (Get_crc(rxbuf, COMMAND_LEN_CANCEL_WARMUP[0]) == rxbuf[COMMAND_LEN_CANCEL_WARMUP
             -[0] - 2])
 721   1          //                 {
 722   1          //                     STATUS1_NOMAL;
 723   1          //                     rxbuf[3] = status[1] & 0xe0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 13  

 724   1          //                     sensor_preheat = 1;
 725   1          //                 }
 726   1          //                 else
 727   1          //                 {
 728   1          //                     rxbuf[3] = (status[1] & 0xe0) | CHECKSUM_EROR;
 729   1          //                 }
 730   1          //                 rxbuf[2] = status[0];
 731   1          //                 rxbuf[COMMAND_LEN_CANCEL_WARMUP[1] - 2] = Get_crc(rxbuf, COMMAND_LEN_CANCEL_WARMUP[
             -1]);
 732   1          //                 rxbuf[COMMAND_LEN_CANCEL_WARMUP[1] - 1] = 0x55;
 733   1          //                 for (i = 0; i < COMMAND_LEN_CANCEL_WARMUP[1]; i++)
 734   1          //                 {
 735   1          //                     uart_send(rxbuf[i]);
 736   1          //                     /* 串口输出 延时函数 关键参数 */
 737   1          //                     Delay1ms(5);
 738   1          //                 }
 739   1          //                 break;
 740   1          //             }
 741   1          //             default:
 742   1          //             {
 743   1          //                 break;
 744   1          //             }
 745   1          //             }
 746   1          //             break;
 747   1          //         }
 748   1          //         default:
 749   1          //         {
 750   1          //             break;
 751   1          //         }
 752   1          //         }
 753   1          //         rxidx = 0;
 754   1          //         rxfinish = 0;
 755   1      
 756   1          //         /* 使能UART0接收 */
 757   1          //         UART0_RX_ENABLE;
 758   1          //     }
 759   1      
 760   1          //     /* 1小时时间到就进行一次寿命比较 */
 761   1          //     if (timer2_life_hour_flag == 1)
 762   1          //     {
 763   1          //         timer2_life_hour_flag = 0;
 764   1      
 765   1          //         /* Brown-Out Detector 电源电压检测 */
 766   1          //         check_BOD();
 767   1          //         /* 读取当前时间 存入Time_Code */
 768   1          //         Master_Read_Data();
 769   1      
 770   1          //         /* XXX 从Flash中读取生产日期 */
 771   1          //         ReadData(dateofmanufacture, RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD], 5);
 772   1          //         /* 读取生产日期失败 则设置默认生产日期为 15年12月31日23时59分 */
 773   1          //         if (dateofmanufacture[0] >= 255 || (dateofmanufacture[1] >= 255) || (dateofmanufacture[2] >
             -= 255))
 774   1          //         {
 775   1          //             dateofmanufacture[0] = 15;
 776   1          //             dateofmanufacture[1] = 12;
 777   1          //             dateofmanufacture[2] = 31;
 778   1          //             dateofmanufacture[3] = 23;
 779   1          //             dateofmanufacture[4] = 59;
 780   1          //         }
 781   1      
 782   1          //         /* 进行读取的当前时间和记录的生产日期的比较 */
 783   1          //         /* 当前时间的年 大于 生产日期中的年 */
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 14  

 784   1          //         if (i2c_time_code[6] >= dateofmanufacture[0])
 785   1          //         {
 786   1          //             /* 计算年差 */
 787   1          //             dateofmanufacture[0] = i2c_time_code[6] - dateofmanufacture[0];
 788   1          //             /* 年差 已经到达五年 如 2020 - 2015 = 5 */
 789   1          //             if (dateofmanufacture[0] == SENSOR_LIFE)
 790   1          //             {
 791   1          //                 /* 当前时间的月 大于 生产日期中的月 2020.6 > 2015.5 */
 792   1          //                 if (i2c_time_code[5] > dateofmanufacture[1])
 793   1          //                 {
 794   1          //                     /* 已使用年数 加1 变为6 */
 795   1          //                     dateofmanufacture[0]++;
 796   1          //                 }
 797   1          //                 /* 当前时间的月 等于 生产日期中的月 2020.5 = 2015.5 */
 798   1          //                 if (i2c_time_code[5] == dateofmanufacture[1])
 799   1          //                 {
 800   1          //                     /* 当前时间的日 大于 生产日期中的日 2020.5.6 > 2015.5.5 */
 801   1          //                     if (i2c_time_code[3] > dateofmanufacture[2])
 802   1          //                     {
 803   1          //                         /* 已使用年数 加1 变为6 */
 804   1          //                         dateofmanufacture[0]++;
 805   1          //                     }
 806   1          //                     /* 当前时间的日 等于 生产日期中的日 2020.5.5 = 2015.5.5 */
 807   1          //                     if (i2c_time_code[3] == dateofmanufacture[2])
 808   1          //                     {
 809   1          //                         /* 以此类推比较时 */
 810   1          //                         if (i2c_time_code[2] > dateofmanufacture[3])
 811   1          //                         {
 812   1          //                             /* 已使用年数 加1 变为6 */
 813   1          //                             dateofmanufacture[0]++;
 814   1          //                         }
 815   1          //                         /* 时相等 */
 816   1          //                         if (i2c_time_code[2] == dateofmanufacture[3])
 817   1          //                         {
 818   1          //                             /* 以此类推比较分 */
 819   1          //                             if (i2c_time_code[1] > dateofmanufacture[4])
 820   1          //                             {
 821   1          //                                 /* 已使用年数 加1 变为6 */
 822   1          //                                 dateofmanufacture[0]++;
 823   1          //                             }
 824   1          //                         }
 825   1          //                     }
 826   1          //                 }
 827   1          //             }
 828   1      
 829   1          //             /* 使用寿命超时 5年时间到 */
 830   1          //             if (dateofmanufacture[0] > SENSOR_LIFE)
 831   1          //             {
 832   1          //                 /* 传感器寿命灯开 */
 833   1          //                 LED_LIFE_ON;
 834   1          //                 /* XXX */
 835   1          //                 if (Life_Write_Flag == 0)
 836   1          //                 {
 837   1          //                     Life_Write_Flag = 1;
 838   1      
 839   1          //                     /* XXX 从FLASH中读取 寿命到期存储地址 的第一个字节 1代表失效，0代表未失效 */
 840   1          //                     ReadData(dateofmanufacture, RECORD_FIRST_ADDRESS[LIFE_RECORD], 1);
 841   1          //                     /* XXX 该字节为0 或者 大于应存的到期记录1条 */
 842   1          //                     if (dateofmanufacture[0] == 0 || (dateofmanufacture[0] > RecordLEN[LIFE_RECORD]
             -))
 843   1          //                     {
 844   1          //                         /* Brown-Out Detector 电源电压检测 */
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 15  

 845   1          //                         check_BOD();
 846   1          //                         /* 写寿命到期记录 */
 847   1          //                         WriteRecordData(LIFE_RECORD);
 848   1          //                     }
 849   1          //                 }
 850   1          //             }
 851   1          //             else
 852   1          //             {
 853   1          //                 if (Life_Check_flag == 1)
 854   1          //                 {
 855   1          //                     /* 传感器寿命灯关 */
 856   1          //                     LED_LIFE_OFF;
 857   1          //                 }
 858   1          //             }
 859   1          //         }
 860   1          //     }
 861   1      
 862   1          //     /* 读取按键 P0.7 的值 检查自检功能是否触发 */
 863   1          //     Test_key = P07 & 0x01;
 864   1          //     /* 测试键按下 */
 865   1          //     if (Test_key == 0x00)
 866   1          //     {
 867   1          //         /* 延时去抖 */
 868   1          //         Delay1ms(30);
 869   1          //         /* 确认测试键按下 */
 870   1          //         if (Test_key == 0x00)
 871   1          //         {
 872   1          //             /* XXX */
 873   1          //             if (!key_long_press_flag)
 874   1          //             {
 875   1          //                 timer2_key_long_press_count = 0;
 876   1          //                 key_long_press_flag = 1;
 877   1          //             }
 878   1          //             /* 这里等于6 通过实际测试出延时时间为11s 国标规定测试键按下后 在7~30s内 应触发继电器 阀
             - */
 879   1          //             if (timer2_key_long_press_count >= 6)
 880   1          //             {
 881   1          //                 /* XXX 阀 */
 882   1          //                 if (!VALVE_flag)
 883   1          //                 {
 884   1          //                     VALVE_flag = 1;
 885   1      
 886   1          //                     /* 电磁阀开 */
 887   1          //                     VALVE_ON;
 888   1          //                     Delay1ms(30);
 889   1      
 890   1          //                     /* 电磁阀关 */
 891   1          //                     VALVE_OFF;
 892   1          //                     Delay1ms(30);
 893   1          //                 }
 894   1          //                 /* 继电器开 */
 895   1          //                 DELAY_ON;
 896   1          //                 timer2_key_long_press_count = 8;
 897   1          //             }
 898   1          //             Light_Flash();
 899   1          //         }
 900   1          //     }
 901   1          //     /* 测试键未按下 */
 902   1          //     else
 903   1          //     {
 904   1          //         /* XXX */
 905   1          //         if (key_long_press_flag)
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 16  

 906   1          //         {
 907   1          //             /* 延时去抖 */
 908   1          //             Delay1ms(30);
 909   1          //             /* 确认测试键未按下 */
 910   1          //             if (Test_key != 0x00)
 911   1          //             {
 912   1          //                 key_long_press_flag = 0;
 913   1          //                 VALVE_flag = 0;
 914   1          //                 if (!sensor_preheat)
 915   1          //                 {   
 916   1          //                     /* 继电器关 */
 917   1          //                     DELAY_OFF;
 918   1          //                 }
 919   1          //             }
 920   1          //         }
 921   1          //     }
 922   1      
 923   1          //     /* 得到ADC采样并滤波之后的值 超过 ch4_3500 的报警阈值 报警状态处理 */
 924   1          //     if (CH4_Adc_Valu >= ch4_3500)
 925   1          //     {
 926   1          //         /* Brown-Out Detector 电源电压检测 */
 927   1          //         check_BOD();
 928   1          //         /* 预热完成 */
 929   1          //         if (sensor_preheat)
 930   1          //         {
 931   1          //             /* 设置为报警状态 */
 932   1          //             STATUS1_ALARM;
 933   1          //             /* 设置P0.0为推挽输出模式 */
 934   1          //             P0M1 = 0x00;
 935   1          //             P0M2 = 0x01;
 936   1      
 937   1          //             /* XXX */
 938   1          //             if (Delay1s_flag == 1)
 939   1          //             {
 940   1          //                 Delay1s_flag = 0;
 941   1          //                 /* XXX */
 942   1          //                 Alarm_Count++;
 943   1      
 944   1          //                 /* 报警次数等于 3 */
 945   1          //                 if (Alarm_Count == 3)
 946   1          //                 {
 947   1          //                     Alarm_flag = 1;
 948   1          //                 }
 949   1      
 950   1          //                 /* 报警次数大于 5 */
 951   1          //                 if (Alarm_Count > 5)
 952   1          //                 {
 953   1          //                     Alarm_Count = 5;
 954   1          //                     /* 继电器开 */
 955   1          //                     DELAY_ON;
 956   1          //                     /* XXX Alarm_Value 为8的倍数 */
 957   1          //                     if (!(Alarm_Value % 8))
 958   1          //                     {
 959   1          //                         /* 电磁阀开 */
 960   1          //                         VALVE_ON;
 961   1          //                         Delay1ms(30);
 962   1      
 963   1          //                         /* 电磁阀关 */
 964   1          //                         VALVE_OFF;
 965   1          //                         Delay1ms(30);
 966   1          //                     }
 967   1          //                     Alarm_Value++;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 17  

 968   1          //                 }
 969   1          //             }
 970   1      
 971   1          //             /* 报警次数等于 3 Alarm_flag = 1 */
 972   1          //             if (Alarm_flag == 1)
 973   1          //             {
 974   1          //                 {
 975   1          //                     Alarm_flag = 0;
 976   1          //                     Alarm_Back_flag = 1;
 977   1          //                     /* Brown-Out Detector 电源电压检测 */
 978   1          //                     check_BOD();
 979   1          //                     /* 向FLASH中 写报警记录 */
 980   1          //                     WriteRecordData(ALARM_RECORD);
 981   1          //                 }
 982   1          //             }
 983   1      
 984   1          //             /* 报警次数大于3等于 */
 985   1          //             if (Alarm_Count >= 3)
 986   1          //             {
 987   1          //                 /* 发出报警声光信号 */
 988   1          //                 Light_Alarm_Flash();
 989   1          //             }
 990   1          //         }
 991   1          //     }
 992   1          //     /* 得到ADC采样并滤波之后的值 小于 Short_Fault_L 的故障阈值 故障状态处理 */
 993   1          //     else if (CH4_Adc_Valu <= Short_Fault_L)
 994   1          //     {
 995   1          //         /* Brown-Out Detector 电源电压检测 */
 996   1          //         check_BOD();
 997   1      
 998   1          //         /* 预热完成 */
 999   1          //         if (sensor_preheat)
1000   1          //         {
1001   1          //             /* 设置系统状态为故障状态 */
1002   1          //             STATUS1_FAULT;
1003   1      
1004   1          //             Alarm_Count = 0;
1005   1          //             Alarm_Value = 0;
1006   1      
1007   1          //             /* 报警灯关 */
1008   1          //             LED_ALARM_OFF;
1009   1          //             /* 继电器关 */
1010   1          //             DELAY_OFF;
1011   1      
1012   1          //             /* XXX */
1013   1          //             Fault_Count++;
1014   1          //             if (Fault_Count == 1)
1015   1          //             {
1016   1          //                 Fault_flag = 1;
1017   1          //             }
1018   1          //             if (Fault_Count > 2)
1019   1          //             {
1020   1          //                 Fault_Count = 2;
1021   1          //             }
1022   1      
1023   1          //             /* 故障声光信号 */
1024   1          //             Fault_Flash();
1025   1      
1026   1          //             /* XXX */
1027   1          //             if (Fault_flag == 1)
1028   1          //             {
1029   1          //                 Fault_flag = 0;
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 18  

1030   1          //                 Fault_Back_flag = 1;
1031   1          //                 /* Brown-Out Detector 电源电压检测 */
1032   1          //                 check_BOD();
1033   1          //                 /* 向FLASH中 写故障记录 */
1034   1          //                 WriteRecordData(FAULT_RECORD);
1035   1          //             }
1036   1          //         }
1037   1          //     }
1038   1          //     /* 得到ADC采样并滤波之后的值 大于 Short_Fault_L 的故障阈值 小于 ch4_3500 的报警阈值 正常状态处
             - */
1039   1          //     else
1040   1          //     {
1041   1          //         if (Delay_Time_Flag)
1042   1          //         {
1043   1          //             STATUS1_NOMAL;
1044   1          //         }
1045   1          //         /* Brown-Out Detector 电源电压检测 */
1046   1          //         check_BOD();
1047   1      
1048   1          //         /* XXX */
1049   1          //         Alarm_flag = 0;
1050   1          //         Alarm_Count = 0;
1051   1          //         Alarm_Value = 0;
1052   1          //         Fault_flag = 0;
1053   1          //         Fault_Count = 0;
1054   1      
1055   1          //         /* XXX */
1056   1          //         if (Alarm_Back_flag == 1)
1057   1          //         {
1058   1          //             Alarm_Back_flag = 0;
1059   1          //             /* Brown-Out Detector 电源电压检测 */
1060   1          //             check_BOD();
1061   1          //             /* 向FLASH中 写报警恢复记录 */
1062   1          //             WriteRecordData(ALARM_BACK_RECORD);
1063   1          //         }
1064   1      
1065   1          //         /* XXX */
1066   1          //         if (Fault_Back_flag == 1)
1067   1          //         {
1068   1          //             Fault_Back_flag = 0;
1069   1          //             Fault_flag = 0;
1070   1      
1071   1          //             /* Brown-Out Detector 电源电压检测 */
1072   1          //             check_BOD();
1073   1          //             /* 向FLASH中 写故障恢复记录 */
1074   1          //             WriteRecordData(FAULT_BACK_RECORD);
1075   1          //         }
1076   1      
1077   1          //         /* 报警灯关 */
1078   1          //         LED_ALARM_OFF;
1079   1          //         /* 故障灯关 */
1080   1          //         LED_FAULT_OFF;
1081   1      
1082   1          //         /* 蜂鸣器1关 */
1083   1          //         SOUND1_OFF;
1084   1          //         /* 蜂鸣器2关 */
1085   1          //         SOUND2_OFF;
1086   1          //         /* 电磁阀关 */
1087   1          //         VALVE_OFF;
1088   1      
1089   1          //         /* XXX */
1090   1          //         if (!VALVE_flag)
C51 COMPILER V9.60.0.0   MAIN                                                              02/01/2020 23:17:19 PAGE 19  

1091   1          //         {
1092   1          //             /* 继电器关 */
1093   1          //             DELAY_OFF;
1094   1          //         }
1095   1          //     }
1096   1          // }
1097   1      }
1098          
1099          /*******************************************************************************
1100           *                 File Static Function Define Section ('static function')
1101           ******************************************************************************/
1102          
1103          /*******************************************************************************
1104           *                 End of File ('EOF')
1105           ******************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     25    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
