C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE ADC
OBJECT MODULE PLACED IN .\Objects\adc.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE ..\..\Code\Source\adc.c LARGE OPTIMIZE(8,SPEED) BROWSE 
                    -INCDIR(..\..\Code\Include) DEBUG OBJECTEXTEND PRINT(.\Listings\adc.lst) TABS(2) OBJECT(.\Objects\adc.obj)

line level    source

   1          /**
   2           *******************************************************************************
   3           * @copyright 2017-2020, Electronic Technology Co. Ltd
   4           * @file      adc.c
   5           * @version   V1.0.0
   6           * @brief     
   7           * @warning   
   8           *******************************************************************************
   9           * @remarks
  10           * 1. Version                Date                 Author
  11           *    v1.0.0                 2020年1月1日          Unknown
  12           *    Modification: 创建文档
  13           *******************************************************************************
  14           */
  15          /* NEED FIX */
  16          /*******************************************************************************
  17           *                 Include File Section ('#include')
  18           ******************************************************************************/
  19          #include "N79E81x.h"
  20          #include "GlobalAppDefine.h"
  21          #include "adc.h"
  22          #include "device.h"
  23          
  24          /*******************************************************************************
  25           *                 Macro Define Section ('#define')
  26           ******************************************************************************/
  27          
  28          /*******************************************************************************
  29           *                 Struct Define Section ('typedef')
  30           ******************************************************************************/
  31          
  32          /*******************************************************************************
  33           *                 Normal Prototype Declare Section ('function')
  34           ******************************************************************************/
  35          
  36          /*******************************************************************************
  37           *                 File Static Prototype Declare Section ('static function')
  38           ******************************************************************************/
  39          
  40          /*******************************************************************************
  41           *                 Global Variable Declare Section ('variable')
  42           ******************************************************************************/
  43          
  44          /*******************************************************************************
  45           *                 File Static Variable Define Section ('static variable')
  46           ******************************************************************************/
  47          
  48          /*******************************************************************************
  49           *                 Normal Function Define Section ('function')
  50           ******************************************************************************/
  51          void adc_init(void)
  52          {
  53   1          /* 关闭P0.1 的数字逻辑输入输出功能 设置P0.1 为输入(高阻)模式 */
  54   1          adc_set_input_mode(E_CHANNEL0);
C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 2   

  55   1          /* AADR2 AADR1 AADR2 = 000B 选择ADC0 即P0.1作为ADC采样端口 */
  56   1          adc_channel_sel(E_CHANNEL0);
  57   1      
  58   1          /* 打开ADC电路 */
  59   1          set_ADCEN;
  60   1      }
  61          
  62          void adc_set_input_mode(enum E_ADCCNL_SEL channel)
  63          {
  64   1          switch (channel)
  65   1          {
  66   2          case E_CHANNEL0:
  67   2              /* 关闭P0.1 的数字逻辑输入输出功能 */
  68   2              P0DIDS |= SET_BIT1;
  69   2              /* 设置P0.1 输入(高阻)模式 */
  70   2              P0M1 = SET_BIT1;
  71   2              P0M2 = 0x00;
  72   2              break;
  73   2          case E_CHANNEL1:        // ADC1(P0.2) is input-only mode
  74   2              P0DIDS |= SET_BIT2; // Disable digital function for P0.2
  75   2              P0M1 = SET_BIT2;
  76   2              P0M2 = 0x00;
  77   2              break;
  78   2          case E_CHANNEL2:        // ADC2(P0.3) is input-only mode
  79   2              P0DIDS |= SET_BIT3; // Disable digital function for P0.3
  80   2              P0M1 = SET_BIT3;
  81   2              P0M2 = 0x00;
  82   2              break;
  83   2          case E_CHANNEL3:        // ADC3(P0.4) is input-only mode
  84   2              P0DIDS |= SET_BIT4; // Disable digital function for P0.4
  85   2              P0M1 = SET_BIT4;
  86   2              P0M2 = 0x00;
  87   2              break;
  88   2          case E_CHANNEL4:        // ADC4(P0.5) is input-only mode
  89   2              P0DIDS |= SET_BIT5; // Disable digital function for P0.5
  90   2              P0M1 = SET_BIT5;
  91   2              P0M2 = 0x00;
  92   2              break;
  93   2          case E_CHANNEL5:        // ADC5(P0.6) is input-only mode
  94   2              P0DIDS |= SET_BIT6; // Disable digital function for P0.6
  95   2              P0M1 = SET_BIT6;
  96   2              P0M2 = 0x00;
  97   2              break;
  98   2          case E_CHANNEL6:        // ADC6(P0.7) is input-only mode
  99   2              P0DIDS |= SET_BIT7; // Disable digital function for P0.7
 100   2              P0M1 = SET_BIT7;
 101   2              P0M2 = 0x00;
 102   2              break;
 103   2          case E_CHANNEL7:       // ADC7(P2.6) is input-only mode(28 pin only)
 104   2              AUXR1 |= SET_BIT3; // Disable digital function for P2.6
 105   2              P2M1 = SET_BIT6;
 106   2              P2M2 = 0x00;
 107   2              break;
 108   2          }
 109   1      }
 110          
 111          void adc_channel_sel(enum E_ADCCNL_SEL channel)
 112          {
 113   1          switch (channel)
 114   1          {
 115   2          /* P0.1 (default) */
 116   2          case E_CHANNEL0:
C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 3   

 117   2              /* AADR2 AADR1 AADR2 = 000B 选择ADC0 即P0.1作为ADC采样端口 */
 118   2              clr_AADR2;
 119   2              clr_AADR1;
 120   2              clr_AADR0;
 121   2              break;
 122   2          case E_CHANNEL1: // P0.2
 123   2              clr_AADR2;
 124   2              clr_AADR1;
 125   2              set_AADR0;
 126   2              break;
 127   2          case E_CHANNEL2: // P0.3
 128   2              clr_AADR2;
 129   2              set_AADR1;
 130   2              clr_AADR0;
 131   2              break;
 132   2          case E_CHANNEL3: // P0.4
 133   2              clr_AADR2;
 134   2              set_AADR1;
 135   2              set_AADR0;
 136   2              break;
 137   2          case E_CHANNEL4: // P0.5
 138   2              set_AADR2;
 139   2              clr_AADR1;
 140   2              clr_AADR0;
 141   2              break;
 142   2          case E_CHANNEL5: // P0.6
 143   2              set_AADR2;
 144   2              clr_AADR1;
 145   2              set_AADR0;
 146   2              break;
 147   2          case E_CHANNEL6: // P0.7
 148   2              set_AADR2;
 149   2              set_AADR1;
 150   2              clr_AADR0;
 151   2              break;
 152   2          case E_CHANNEL7: // P2.6
 153   2              set_AADR2;
 154   2              set_AADR1;
 155   2              set_AADR0;
 156   2              break;
 157   2          }
 158   1      }
 159          
 160          /* 选择ADC0 即P0.1作为ADC采样端口 打开ADC中断使能 */
 161          void adc_init_interrupt(void)
 162          {
 163   1          /* 关闭P0.1 的数字逻辑输入输出功能 设置P0.1 为输入(高阻)模式 */
 164   1          adc_set_input_mode(E_CHANNEL0);
 165   1          /* AADR2 AADR1 AADR2 = 000B 选择ADC0 即P0.1作为ADC采样端口 */
 166   1          adc_channel_sel(E_CHANNEL0);
 167   1      
 168   1          /* 打开ADC中断和全局中断 */
 169   1          adc_enable_interrupt();
 170   1          /* 打开ADC电路 */
 171   1          set_ADCEN;
 172   1      }
 173          
 174          void adc_enable_interrupt(void)
 175          {
 176   1          /* 打开ADC中断 */
 177   1          EADC = 1;
 178   1          /* 打开全局中断 */
C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 4   

 179   1          EA = 1;
 180   1      }
 181          
 182          uint16_t adc_sensor(void)
 183          {
 184   1          uint16_t temp[10];
 185   1          uint8_t i;
 186   1      
 187   1          /* 采集10次用来滤波 */
 188   1          for (i = 0; i < 10; i++)
 189   1          {
 190   2              /* 获取单次的ADC采样结果 */
 191   2              temp[i] = adc_single_sample();
 192   2          }
 193   1      
 194   1          /* 返回滤波后的值 */
 195   1          return adc_sensor_filter(temp);
 196   1      }
 197          
 198          uint16_t adc_single_sample(void)
 199          {
 200   1          uint16_t u16_ADCL;
 201   1          uint16_t u16_ADC;
 202   1          adc_trigger_convertion();
 203   1      
 204   1          /* 从ADCCON0获取 ADC 10bit 采集值的最后2个bit ADC.1 ADC.0 ADC[1:0]*/
 205   1          u16_ADCL = ADCCON0;
 206   1          u16_ADCL = u16_ADCL >> 6;
 207   1          /* 从ADCH中获取 ADC 转换结果位 ADC[9:2] */
 208   1          u16_ADC = ADCH;
 209   1          /* 将ADC的采样结果合成 10bit */
 210   1          u16_ADC = (u16_ADC << 2) + u16_ADCL;
 211   1      
 212   1          return u16_ADC;
 213   1      }
 214          
 215          void adc_trigger_convertion(void)
 216          {
 217   1          /* Clear ADC flag 
 218   1              - ADCI = 0 ADC空闲
 219   1              - ADCI = 1 ADC转换结果已经可以读取 如果中断使能 会产生一个中断 不能由软件置位
 220   1              */
 221   1          clr_ADCI;
 222   1      
 223   1          /* 设置该位开始A/D转换 
 224   1              - 如果ADCEX为1 也由STADC置位 当ADC忙时该位保持高 在ADCI置位后立即复位
 225   1              - 在置位ADCS之前建议先清ADCI 然而 如果ADCI清零与ADCS置位同时进行 相同通道将开始一次新的A/D 转换
 226   1              - 软件清ADCS将中止转换 当ADCS或ADCI为高时 ADC 不能进行新的转换 
 227   1              */
 228   1          set_ADCS;
 229   1      
 230   1          /* 空闲模式 设置该位使MCU进入空闲模式 
 231   1              - 在此模式下 CPU时钟停止 且程序计数器PC挂起
 232   1              - CPU从空闲模式唤醒后 该位自动由硬件清零 且在系统唤醒之前程序继续执行中断服务程序ISR
 233   1              - 从ISR返回后 设备继续执行系统进入掉电模式时所处的指令 
 234   1              */
 235   1          PCON |= SET_BIT0;
 236   1      
 237   1          /* Brown-Out Detector 电源电压检测 */
 238   1          check_BOD();
 239   1      }
 240          
C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 5   

 241          /* XXX 可以不使用 ptemp 只使用 p 指针即可 */
 242          uint16_t adc_sensor_filter(uint16_t *p)
 243          {
 244   1          uint8_t i;
 245   1          uint32_t sum = 0;
 246   1          uint16_t maxtemp = 0, mintemp = 0;
 247   1          uint16_t *ptemp = p;
 248   1      
 249   1          for (i = 0; i < 10; i++)
 250   1          {
 251   2              /* Brown-Out Detector 电源电压检测 */
 252   2              check_BOD();
 253   2              /* 第一次采样 */
 254   2              if (!i)
 255   2              {
 256   3                  /* 总值等于第一个数组成员的值 */
 257   3                  sum = *ptemp;
 258   3                  /* 最大、最小值等于总值 */
 259   3                  maxtemp = mintemp = sum;
 260   3              }
 261   2              else
 262   2              {
 263   3                  /* 总值累加 */
 264   3                  sum += *(ptemp + i);
 265   3                  /* 获取十次采样中的最大值 */
 266   3                  if (*(ptemp + i) > maxtemp)
 267   3                      maxtemp = *(ptemp + i);
 268   3      
 269   3                  /* 获取十次采样中的最小值 */
 270   3                  if (*(ptemp + i) < mintemp)
 271   3                      mintemp = *(ptemp + i);
 272   3              }
 273   2          }
 274   1      
 275   1          /* 总值中去掉最大值和最小值 */
 276   1          sum -= (maxtemp + mintemp);
 277   1          /* 总值除以8 因为已经去掉两个成员 最大值和最小值 */
 278   1          sum = sum >> 3;
 279   1      
 280   1          return (uint16_t)sum;
 281   1      }
 282          
 283          /* ADC 采样中断服务程序 Vecotr @ 0x5B */
 284          void ADC_ISR(void) interrupt 11
 285          {   
 286   1          /* Clear ADC flag 
 287   1              - ADCI = 0 ADC空闲
 288   1              - ADCI = 1 ADC转换结果已经可以读取 如果中断使能 会产生一个中断 不能由软件置位
 289   1          */
 290   1          clr_ADCI;
 291   1      
 292   1          /* 设置该位开始A/D转换 
 293   1              - 如果ADCEX为1 也由STADC置位 当ADC忙时该位保持高 在ADCI置位后立即复位
 294   1              - 在置位ADCS之前建议先清ADCI 然而 如果ADCI清零与ADCS置位同时进行 相同通道将开始一次新的A/D 转换
 295   1              - 软件清ADCS将中止转换 当ADCS或ADCI为高时 ADC 不能进行新的转换 
 296   1          */
 297   1          clr_ADCS;
 298   1      }
 299          
 300          /*******************************************************************************
 301           *                 File Static Function Define Section ('static function')
 302           ******************************************************************************/
C51 COMPILER V9.60.0.0   ADC                                                               02/01/2020 22:44:46 PAGE 6   

 303          
 304          /*******************************************************************************
 305           *                 End of File ('EOF')
 306           ******************************************************************************/
 307          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    736    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      33
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
