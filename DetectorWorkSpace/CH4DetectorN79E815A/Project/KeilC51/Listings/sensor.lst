C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SENSOR
OBJECT MODULE PLACED IN .\Objects\sensor.obj
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE ..\..\Code\Source\sensor.c LARGE OPTIMIZE(8,SPEED) BROW
                    -SE INCDIR(..\..\Code\Include) DEBUG OBJECTEXTEND PRINT(.\Listings\sensor.lst) TABS(2) OBJECT(.\Objects\sensor.obj)

line level    source

   1          /**
   2           *******************************************************************************
   3           * @copyright 2017-2020, Electronic Technology Co. Ltd
   4           * @file      sensor.c
   5           * @version   V1.0.0
   6           * @brief     
   7           * @warning   
   8           *******************************************************************************
   9           * @remarks
  10           * 1. Version                Date                 Author
  11           *    v1.0.0                 2020年1月1日          Unknown
  12           *    Modification: 创建文档
  13           *******************************************************************************
  14           */
  15          /* NEED FIX */
  16          /*******************************************************************************
  17           *                 Include File Section ('#include')
  18           ******************************************************************************/
  19          #include "N79E81x.h"
  20          #include "GlobalAppDefine.h"
  21          
  22          #include "sensor.h"
  23          #include "signal.h"
  24          #include "delay.h"
  25          #include "adc.h"
  26          #include "uart.h"
  27          #include "i2c.h"
  28          #include "utlities.h"
  29          
  30          /*******************************************************************************
  31           *                 Macro Define Section ('#define')
  32           ******************************************************************************/
  33          
  34          /*******************************************************************************
  35           *                 Struct Define Section ('typedef')
  36           ******************************************************************************/
  37          
  38          /*******************************************************************************
  39           *                 File Static Prototype Declare Section ('static function')
  40           ******************************************************************************/
  41          
  42          /*******************************************************************************
  43           *                 Global Variable Declare Section ('variable')
  44           ******************************************************************************/
  45          /* 预热标记 */
  46          bit sensor_preheat = false;
  47          
  48          /* 预热时间计数 */
  49          uint16_t sensor_preheat_time_count = 0;
  50          
  51          /* 甲烷 零点AD值 */
  52          uint16_t ch4_0 = 0;
  53          /* 甲烷 3500点AD值 */
  54          uint16_t ch4_3500 = 712;
C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 2   

  55          /* 标定AD值存储数组 */
  56          uint8_t demarcation_result[4] = 0;
  57          
  58          /*******************************************************************************
  59           *                 File Static Variable Define Section ('static variable')
  60           ******************************************************************************/
  61          
  62          /*******************************************************************************
  63           *                 Normal Function Define Section ('function')
  64           ******************************************************************************/
  65          /* 标定函数 */
  66          /*  1.按键按下 消抖后
  67              2.电源灯声音闪亮3声,声音与报警和故障声不同，随后进入3分钟预热
  68              3.开始读取AD，if ((adc_value < 41) || (adc_value > 260))，则认为是故障，故障灯闪亮，标定失败
  69              4.if (adc_value < 410)，则电源，故障，报警灯全亮，等待。若>=410，则故障、报警灯闪亮100s左右以指示
  70              5.if ((temp_data < 410)||(temp_data > 950))，则反应值不合法，故障灯亮，标定失败
  71              6.标定成功，报警灯常亮。进入死循环等待重启
  72              */
  73          void sersor_demarcation(void)
  74          {
  75   1          uint8_t demarcate_key;
  76   1          uint16_t i = 0;
  77   1          uint16_t adc_value = 0;
  78   1          uint16_t temp_data = 0;
  79   1          uint16_t delay_count = 0;
  80   1      
  81   1          /* 读取 P0.6 的值 sbit P06 = P0 ^ 6 (sbit 和 ^ 操作 指为寄存器某位取的别称 为C51特殊类型 而非异或) */
  82   1          demarcate_key = P06 & 0x01;
  83   1      
  84   1          /* 调试键按下 */
  85   1          if (demarcate_key == 0x00)
  86   1          {
  87   2              /* 延时去抖 */
  88   2              Delay1ms(50);
  89   2              /* 中止定时器2->关闭电源灯闪烁 清该位将中止定时器2并将当前计数保存在TH2和TL2 */
  90   2              TR2 = 0;
  91   2              /* 再次获取P0.6 的值 */
  92   2              demarcate_key = P06 & 0x01;
  93   2              /* 确认调试键按下 */
  94   2              if (demarcate_key == 0x00)
  95   2              {
  96   3                  /* 标定状态的声光提示 闪亮，响一声 */
  97   3                  device_alarm(Alarm_Demarcation);
  98   3                  
  99   3                  /* 选择ADC0 即P0.1作为ADC采样端口 打开ADC中断使能 */
 100   3                  adc_init_interrupt();
 101   3      
 102   3                  /* 设备预热标记为已预热 */
 103   3                  sensor_preheat = true;
 104   3                  
 105   3                  /* 等待 255 * 2 = 510s XXX 预热 */
 106   3                  for (i = 0; i < 225; i++)
 107   3                  {
 108   4                      /* 电源灯开 */
 109   4                      LED_POWER_ON;
 110   4                      Delay1ms(1500);
 111   4                      /* 电源灯关 */
 112   4                      LED_POWER_OFF;
 113   4                      Delay1ms(500);
 114   4      
 115   4                      /* 通过长按键测试电磁阀和继电器 */
 116   4                      /* 获取P0.7 的值 */
C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 3   

 117   4                      demarcate_key = P07 & 0x01;
 118   4                      /* P0.7 按键按下 */
 119   4                      if (demarcate_key == 0x00)
 120   4                      {
 121   5                          /* 延时去抖 */
 122   5                          Delay1ms(30);
 123   5                          /* 再次获取P0.7 的值 */
 124   5                          demarcate_key = P07 & 0x01;
 125   5                          /* 确认P0.7 按键按下 */
 126   5                          if (demarcate_key == 0x00)
 127   5                          {
 128   6                              /* 电磁阀开 */
 129   6                              VALVE_ON;
 130   6                              Delay1ms(1500);
 131   6                              /* 继电器开 */
 132   6                              DELAY_ON;
 133   6                          }
 134   5                      }
 135   4                      else
 136   4                      {
 137   5                          /* 继电器关  */
 138   5                          DELAY_OFF;
 139   5                          /* 电磁阀关 */
 140   5                          VALVE_OFF;
 141   5                      }
 142   4                  }
 143   3      
 144   3                  /* 得到ADC采样并滤波之后的值 */
 145   3                  adc_value = adc_sensor();
 146   3                  /* 将该采样值存储到ch4_0中 ch4_0为0传感器0点的值 */
 147   3                  ch4_0 = adc_value;
 148   3      
 149   3                  /* 串口输出该次采样的值 */
 150   3                  uart_send(0x1f);
 151   3                  Delay1ms(5);
 152   3                  uart_send(0x1f);
 153   3                  Delay1ms(5);
 154   3                  uart_send(ch4_0 >> 8);
 155   3                  Delay1ms(5);
 156   3                  uart_send(ch4_0);
 157   3                  Delay1ms(5);
 158   3      
 159   3                  /* 再次得到ADC采样并滤波之后的值 */
 160   3                  adc_value = adc_sensor();
 161   3      
 162   3                  while (1)
 163   3                  {
 164   4                      /* 得到ADC采样并滤波之后的值 */
 165   4                      adc_value = adc_sensor();
 166   4                      
 167   4                      /* 采样值点 合理性判断 AD超出范围 0.2V-1.27V 则故障灯亮 */
 168   4                      if ((adc_value < 41) || (adc_value > 260))
 169   4                      {
 170   5                          Delay1ms(1000);
 171   5                          if ((adc_value < 41) || (adc_value > 260))
 172   5                          {
 173   6                              while (1)
 174   6                              {   
 175   7                                  /* 故障灯开 */
 176   7                                  LED_FAULT_ON;
 177   7                                  Delay1ms(500);
 178   7      
C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 4   

 179   7                                  /* 故障灯关 */
 180   7                                  LED_FAULT_OFF;
 181   7                                  Delay1ms(500);
 182   7                              }
 183   6                          }
 184   5                      }
 185   4      
 186   4                      /* 仅当ADC采样值小于410时执行 当采样值大于410时 退出该循环 此举在等待气体浓度上升 */
 187   4                      do
 188   4                      {
 189   5                          /* 再次得到ADC采样并滤波之后的值 */
 190   5                          adc_value = adc_sensor();
 191   5      
 192   5                          /* <1> 电源 故障 报警 三灯常亮 */
 193   5                          /* 电源灯开 */
 194   5                          LED_POWER_ON;
 195   5                          /* 故障灯开 */
 196   5                          LED_FAULT_ON;
 197   5                          /* 报警灯开 */
 198   5                          LED_ALARM_ON;
 199   5      
 200   5                          /* 周期性 串口输出采样的值 */
 201   5                          if (++delay_count > 1200)
 202   5                          {
 203   6                              delay_count = 0;
 204   6                              uart_send(0x2f);
 205   6                              Delay1ms(5);
 206   6                              uart_send(0x2f);
 207   6                              Delay1ms(5);
 208   6                              uart_send(adc_value >> 8);
 209   6                              Delay1ms(5);
 210   6                              uart_send(adc_value);
 211   6                              Delay1ms(5);
 212   6                          }
 213   5                      } while (adc_value < 410);
 214   4      
 215   4                      Delay1ms(250);
 216   4                      Delay1ms(250);
 217   4      
 218   4                      /* Wait 120s 此举在等待气体浓度上升 */
 219   4                      for (i = 0; i <= 300; i++)
 220   4                      {
 221   5                          /* <2> 电源灯常亮 报警故障两颗灯闪烁 */
 222   5                          Delay1ms(500);
 223   5      
 224   5                          /* 报警灯开 */
 225   5                          LED_ALARM_ON;
 226   5                          /* 故障灯开 */
 227   5                          LED_FAULT_ON;
 228   5      
 229   5                          Delay1ms(1500);
 230   5      
 231   5                          /* 报警灯关 */
 232   5                          LED_ALARM_OFF;
 233   5                          /* 故障灯关 */
 234   5                          LED_FAULT_OFF;
 235   5      
 236   5                          /* 串口输出该次采样的值 */
 237   5                          uart_send(0x3f);
 238   5                          Delay1ms(5);
 239   5                          uart_send(0x3f);
 240   5                          Delay1ms(5);
C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 5   

 241   5                          uart_send(adc_value >> 8);
 242   5                          Delay1ms(5);
 243   5                          uart_send(adc_value);
 244   5                          Delay1ms(5);
 245   5                      }
 246   4      
 247   4                      /* 暂存得到ADC采样并滤波之后的值 */
 248   4                      temp_data = adc_sensor();
 249   4      
 250   4                      /* 采样值 合理性判断 AD超出范围 ADC_result < 410 or  ADC_result > 950 */
 251   4                      if ((temp_data < 410) || (temp_data > 950))
 252   4                      {
 253   5                          Delay1ms(1000);
 254   5      
 255   5                          /* 再次得到ADC采样并滤波之后的值 */
 256   5                          temp_data = adc_sensor();
 257   5                          /* 再次确认 采样值 合理性判断 AD超出范围 ADC_result < 410 or  ADC_result > 950 */
 258   5                          if (temp_data < 410 || temp_data > 950)
 259   5                          {
 260   6                          /* <5> 故障状态 故障灯常亮 */
 261   6                          ERROR:
 262   6                              while (1)
 263   6                              {
 264   7                                  LED_FAULT_ON;
 265   7                              }
 266   6                          }
 267   5                      }
 268   4                      /* 采样值 合理性判断 AD在范围内 410 <= ADC_result <= 950 则标定成功 */
 269   4                      else
 270   4                      {
 271   5                          /* <3> 电源灯常亮 报警故障两颗关闭 */
 272   5                          /* 故障灯关 */
 273   5                          LED_FAULT_OFF;
 274   5                          /* 报警灯关 */
 275   5                          LED_ALARM_OFF;
 276   5                          /* 暂存 得到ADC采样并滤波之后的值 */
 277   5                          temp_data = adc_sensor();
 278   5      
 279   5                          /* 将暂存的ADC采样值 存入ch4_3500中 ch4_3500为传感器 3500 XXX 的值 */
 280   5                          ch4_3500 = temp_data;
 281   5      
 282   5                          /* 将零点和3500点的ADC采样数据存入数组中 */
 283   5                          demarcation_result[0] = ch4_0;
 284   5                          demarcation_result[1] = ch4_0 >> 8;
 285   5                          demarcation_result[2] = ch4_3500;
 286   5                          demarcation_result[3] = ch4_3500 >> 8;
 287   5      
 288   5                          /* YYY 将采样结果数组存入FLASH中 */
 289   5                          ///WriteData(demarcation_result, 4, RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD], Life
             -_start_OFFSET_DEMA_CH4_0);
 290   5      
 291   5                          /* 从I2C时钟芯片中读取时间戳 */
 292   5                          i2c_get_time();
 293   5      
 294   5                          /* EBO 为BOD电源电压检测的中断使能位 关中断 sbit EBO = IE ^ 5 */
 295   5                          EBO = 0;
 296   5                          /* 复制从时钟芯片获取的时间戳 */
 297   5                          timecodeTotimecopy();
 298   5                          /* EBO 为BOD电源电压检测的中断使能位 开中断 sbit EBO = IE ^ 5 */
 299   5                          EBO = 1;
 300   5      
 301   5                          /* YYY 存储标定记录总数 */
C51 COMPILER V9.60.0.0   SENSOR                                                            02/01/2020 20:45:29 PAGE 6   

 302   5                          ///WriteRecordData(DEM_RECORD);
 303   5                          
 304   5                          /* YYY 从Flash中读取 ch4_0 与 ch4_3500 数据 并进行比对 */
 305   5                          ///ReadData(i2c_time_code, RECORD_FIRST_ADDRESS[LIFE_START_DATE_RECORD] + Life_start_O
             -FFSET_DEMA_CH4_0, 4);
 306   5      
 307   5                          if (i2c_time_code[0] != demarcation_result[0])
 308   5                              goto ERROR;
 309   5                          if (i2c_time_code[1] != demarcation_result[1])
 310   5                              goto ERROR;
 311   5                          if (i2c_time_code[2] != demarcation_result[2])
 312   5                              goto ERROR;
 313   5                          if (i2c_time_code[3] != demarcation_result[3])
 314   5                              goto ERROR;
 315   5                          
 316   5                          /* 发送标定的报警点数据 ch4_3500 */
 317   5                          uart_send(0x4f);
 318   5                          Delay1ms(5);
 319   5                          uart_send(0x4f);
 320   5                          Delay1ms(5);
 321   5                          uart_send(ch4_3500 >> 8);
 322   5                          Delay1ms(5);
 323   5                          uart_send(ch4_3500);
 324   5                          Delay1ms(5);
 325   5                      }
 326   4      
 327   4                      /* <4> 标定完成 电源 报警灯常亮 故障灯关闭 */
 328   4                      while (1)
 329   4                      {
 330   5                          /* 报警灯开 */
 331   5                          LED_ALARM_ON;
 332   5                      }
 333   4                  }
 334   3              }
 335   2          }
 336   1      }
 337          
 338          /*******************************************************************************
 339           *                 File Static Function Define Section ('static function')
 340           ******************************************************************************/
 341          
 342          /*******************************************************************************
 343           *                 End of File ('EOF')
 344           ******************************************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    816    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     10       9
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
